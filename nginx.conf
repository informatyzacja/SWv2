#user html;
worker_processes  1;

error_log /opt/sw/logs/error.log;
pid        /opt/sw/logs/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    # Nice log format
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
        '$status $body_bytes_sent "$http_referer" '
        '"$http_user_agent" "$http_x_forwarded_for"';
    log_format postdata '$remote_addr - $remote_user [$time_local] "$request" '
        '$status $body_bytes_sent "$http_referer" '
        '"$http_user_agent" "$http_x_forwarded_for" - req data: "$request_body"';
    
    # The default access log, used for everything except receiving a cast vote.
    access_log  /opt/sw/logs/access.log  main;

    # When on an OS supporting the sendfile() API, speed things a bit up
    sendfile on;

    # Don't send out nginx version in the Server: http header
    server_tokens off;

    server {
        # Port to listen to
        listen 8081;

        # A catch-all server name - change this to the target hostname
        server_name _;

        root /opt/sw/empty;

        location ~ ^/v/[A-Za-z0-9_-]*$ {
            return 307 $uri/;
        }

        location ~ ^/v/[A-Za-z0-9_-]*/$ {
            root /opt/sw;
            default_type text/html;
            try_files $uri/index.html =404;
        }

        location ~ ^/v/([A-Za-z0-9_-]*)/vote$ {
            root /opt/sw/empty;
            default_type text/html;

            # Only allow POSTs here
            limit_except POST { deny all; }

            # Save votes to a specific log file
            access_log /opt/sw/logs/vote_log postdata;

            # Allow nginx to log with a request body - that's where vote data will be.
            # A bigger nginx version (e.g. openresty) is required for this to parse and work.
            echo_read_request_body; 

            # If there's no file for that token, tell the browser it did something wrong
            if (!-f /opt/sw/v/$1/index.html) {
                return 400 "Invalid token";
            }

            # After a successfuly cast vote, remove the saved /voting data, so the
            # user cannot see voting options again and cannot successfully vote again
            # Even though logic in nginx is not sequential, this block does not execute
            # if return 400 is met.
            # This requires Openresty for lua support.
            # Do the redirect in lua instead of in nginx because that's how nginx works
            # - we don't want this running if the previous return is met.
            rewrite_by_lua_block {
                -- TODO: this
                --  os.remove("/opt/sw/static/voting?token=" .. ngx.var.arg_token)
                ngx.redirect("/thankyou", 307)
            }
        }

        # A response signifying a token we have no idea about, used in /voting
        location @invalid_token {
            return 400 "Invalid token";
        }

    }

    #server {
        #	listen       80;
        #	server_name  ktp.local;

        #	#charset koi8-r;

        #	#access_log  logs/host.access.log  main;

        #	location = /favicon.ico {
            #		types {}
            #		default_type text/plain;
            #		return 404 "Not found";
            #	}

        #	location /__icons__ {
            #		rewrite ^/__icons__/(.*)$ /$1 break;
            #		root /usr/lib/python3.8/site-packages/flask_silk/icons;
            #		try_files $uri =404;
            #	}

        #	location /__autoindex__ {
            #		root /var/www-prv;
            #		try_files $uri =404;
            #	}

        #	location / {
            #		root   /var/www;
            #		index index.html;
            #		try_files $uri /index.html;
            #	}

        #	location /index.html {
            #		gzip off;
            #		root /var/www;

            #		fastcgi_param SCRIPT_NAME /;
            #		fastcgi_param PATH_INFO $request_uri;
            #		fastcgi_param SCRIPT_FILENAME   /var/www-prv/index.py;

            #		include /etc/nginx/fastcgi_params;

            #		fastcgi_pass unix:/run/fcgiwrap.sock;
            #	}


        #	location /tolino-status.html {
            #		return 204 "";
            #	}
        #	location /tolino-status.php {
            #		return 204 "";
            #	}
        #	location /generate_204 {
            #		return 204 "";
            #	}

        #    # Used in qutebrowser config
        #	location /history-back {
            #	    default_type text/html;
            #        return 200 "<!doctype html><body><script>window.history.go(-2)</script></body>";
            #    }


        #	#error_page  404              /404.html;

        #	# redirect server error pages to the static page /50x.html
        #	#
        #	error_page   500 502 503 504  /50x.html;
        #	location = /50x.html {
            #		root   /usr/share/nginx/html;
            #	}

        #	# proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #	#
        #	#location ~ \.php$ {
            #		#    proxy_pass   http://127.0.0.1;
            #		#}

        #	# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #	#
        #	#location ~ \.php$ {
            #		#    root           html;
            #		#    fastcgi_pass   127.0.0.1:9000;
            #		#    fastcgi_index  index.php;
            #		#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
            #		#    include        fastcgi_params;
            #		#}

        #	# deny access to .htaccess files, if Apache's document root
        #	# concurs with nginx's one
        #	#
        #	#location ~ /\.ht {
            #		#    deny  all;
            #		#}
        #}


    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
        #    listen       8000;
        #    listen       somename:8080;
        #    server_name  somename  alias  another.alias;

        #    location / {
            #        root   html;
            #        index  index.html index.htm;
            #    }
        #}


    # HTTPS server
    #
    #server {
        #    listen       443 ssl;
        #    server_name  localhost;

        #    ssl_certificate      cert.pem;
        #    ssl_certificate_key  cert.key;

        #    ssl_session_cache    shared:SSL:1m;
        #    ssl_session_timeout  5m;

        #    ssl_ciphers  HIGH:!aNULL:!MD5;
        #    ssl_prefer_server_ciphers  on;

        #    location / {
            #        root   html;
            #        index  index.html index.htm;
            #    }
        #}

}
